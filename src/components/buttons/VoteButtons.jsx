'use client'

import React, { useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import { ArrowUpIcon, ArrowDownIcon } from '@heroicons/react/24/outline';
import { clientDB } from '@/supabaseClient';

/**
 * VoteButtons.jsx
 * Loaf Life - Vote Buttons
 * 
 * This component displays upvote and downvote buttons and the current vote count.
 * Users can vote once per item, change their vote, or remove their vote.
 * Votes are persistent and reflected in the UI.
 * 
 * Written with assistance from Google Gemini 2.5 Flash
 * 
 * @author: Nathan O
 * @author: https://gemini.google.com/app
 */

const VoteButtons = ({ itemId, itemType, userId, upvotes: initialUpvotes, downvotes: initialDownvotes, hackId, dealId, eventId }) => {
  const [localUpvotes, setLocalUpvotes] = useState(Number(initialUpvotes) || 0);
  const [localDownvotes, setLocalDownvotes] = useState(Number(initialDownvotes) || 0);
  const [currentUserVoteType, setCurrentUserVoteType] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [errorState, setErrorState] = useState(null);

  useEffect(() => {
    setLocalUpvotes(Number(initialUpvotes) || 0);
    setLocalDownvotes(Number(initialDownvotes) || 0);
  }, [initialUpvotes, initialDownvotes]);

  useEffect(() => {
    if (!userId) {
      setCurrentUserVoteType(null);
      return;
    }

    const currentItemId = itemId || hackId || dealId || eventId;
    const currentItemType = itemType || (hackId ? 'hacks' : dealId ? 'deals' : eventId ? 'events' : null);

    if (!currentItemId) {
      setCurrentUserVoteType(null);
      return;
    }
    if (!currentItemType) {
      setCurrentUserVoteType(null);
      return;
    }
    setErrorState(null);

    const fetchUserVote = async () => {
      setIsLoading(true);
      try {
        let query = clientDB
          .from('user_item_votes')
          .select('vote_type')
          .eq('user_id', userId)
          .eq('item_type', currentItemType);

        if (currentItemType === 'hacks') query = query.eq('hack_id', currentItemId);
        else if (currentItemType === 'deals') query = query.eq('deal_id', currentItemId);
        else if (currentItemType === 'events') query = query.eq('event_id', currentItemId);
        else throw new Error(`Unknown itemType: ${currentItemType} during fetch.`);
        
        const { data, error } = await query.single();

        if (error && error.code !== 'PGRST116') throw error;
        setCurrentUserVoteType(data ? data.vote_type : null);
      } catch (err) {
        console.error('Error fetching user vote:', err);
        setErrorState('Could not fetch your vote status.');
      } finally {
        setIsLoading(false);
      }
    };
    fetchUserVote();
  }, [userId, itemId, itemType, hackId, dealId, eventId]);

  const syncVoteWithDB = async (newItemUpvotes, newItemDownvotes, nextVoteType) => {
    const currentItemId = itemId || hackId || dealId || eventId;
    const currentItemType = itemType || (hackId ? 'hacks' : dealId ? 'deals' : eventId ? 'events' : null);

    if (!userId) {
      setErrorState("Cannot vote: User ID is missing. Please log in.");
      return false;
    }
    if (!currentItemId || !currentItemType) {
        setErrorState("Cannot vote: Item information is missing.");
        return false;
    }

    setIsLoading(true);
    setErrorState(null);

    try {
      // 1. Update item's total votes in its own table (e.g., 'hacks')
      const { error: itemUpdateError } = await clientDB
        .from(currentItemType) 
        .update({ upvotes: newItemUpvotes, downvotes: newItemDownvotes })
        .eq('id', currentItemId);
      if (itemUpdateError) throw itemUpdateError;

      // 2. Manage the specific user's vote in 'user_item_votes'
      const itemIdentifierColumn = 
          currentItemType === 'hacks' ? 'hack_id' :
          currentItemType === 'deals' ? 'deal_id' :
          currentItemType === 'events' ? 'event_id' :
          null;

      if (!itemIdentifierColumn) {
        throw new Error(`Unknown itemType for DB sync: ${currentItemType}`);
      }

      // First, delete any existing vote by this user for this specific item
      // This simplifies logic: we don't need to differentiate between insert and update for the user_item_votes table.
      await clientDB
        .from('user_item_votes')
        .delete()
        .eq('user_id', userId)
        .eq(itemIdentifierColumn, currentItemId);

      // Then, if nextVoteType is not null (i.e., user is casting a new vote or changing vote), insert the new vote.
      // If nextVoteType is null, it means the user is removing their vote, so we only performed the delete above.
      if (nextVoteType) {
        const voteToInsert = {
          user_id: userId,
          item_type: currentItemType,
          vote_type: nextVoteType,
          [itemIdentifierColumn]: currentItemId 
          // The 'id' column of 'user_item_votes' should be auto-generated by the database (e.g., with DEFAULT gen_random_uuid())
          // So, we do not provide it here.
        };

        const { error: insertError } = await clientDB
          .from('user_item_votes')
          .insert(voteToInsert);
        
        if (insertError) {
            // Check if the error is about the 'id' column specifically
            if (insertError.message.includes('null value in column "id"')) {
                console.error("Critical DB Setup Error: The 'id' column in 'user_item_votes' might not be auto-generating UUIDs. Please check table definition in Supabase.", insertError);
                setErrorState("Database configuration error. Could not save vote. (Admin notified)");
            } else if (insertError.code === '23505') { 
                 console.error("Error: Unique constraint violation during vote insert. This might indicate an issue with the delete-then-insert logic or concurrent operations.", insertError);
                 setErrorState("Could not record vote due to a conflict. Please try again.");
            } else {
                throw insertError;
            }
        }
      }
      return true;
    } catch (error) {
      console.error('Error syncing vote with DB:', error);
      setErrorState('Failed to update vote. Please try again.');
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  const handleVote = async (e, voteAction) => {
    e.stopPropagation();
    e.preventDefault();

    if (isLoading || !userId) {
      if(!userId) setErrorState("Please log in to vote.");
      return;
    }

    const originalLocalUpvotes = localUpvotes;
    const originalLocalDownvotes = localDownvotes;
    const originalUserVoteType = currentUserVoteType;

    let newLocalUpvotes = localUpvotes;
    let newLocalDownvotes = localDownvotes;
    let nextUserVoteType = null;

    if (voteAction === 'upvote') {
      if (currentUserVoteType === 'upvoted') {
        newLocalUpvotes = localUpvotes - 1;
        nextUserVoteType = null;
      } else if (currentUserVoteType === 'downvoted') {
        newLocalUpvotes = localUpvotes + 1;
        newLocalDownvotes = localDownvotes - 1;
        nextUserVoteType = 'upvoted';
      } else {
        newLocalUpvotes = localUpvotes + 1;
        nextUserVoteType = 'upvoted';
      }
    } else if (voteAction === 'downvote') {
      if (currentUserVoteType === 'downvoted') {
        newLocalDownvotes = localDownvotes - 1;
        nextUserVoteType = null;
      } else if (currentUserVoteType === 'upvoted') {
        newLocalDownvotes = localDownvotes + 1;
        newLocalUpvotes = localUpvotes - 1;
        nextUserVoteType = 'downvoted';
      } else {
        newLocalDownvotes = localDownvotes + 1;
        nextUserVoteType = 'downvoted';
      }
    }

    // Optimistic UI update
    setLocalUpvotes(newLocalUpvotes);
    setLocalDownvotes(newLocalDownvotes);
    setCurrentUserVoteType(nextUserVoteType);

    const success = await syncVoteWithDB(newLocalUpvotes, newLocalDownvotes, nextUserVoteType);

    if (!success) {
      setLocalUpvotes(originalLocalUpvotes);
      setLocalDownvotes(originalLocalDownvotes);
      setCurrentUserVoteType(originalUserVoteType);
    }
  };


  return (
    <div className="flex flex-col items-center">
      <div className="flex items-center space-x-1.5 bg-[#F5EFE6] border-2 border-[#A0522D] text-[#A0522D] px-3 py-0.5 rounded-lg shadow-md">
        <button
          onClick={(e) => handleVote(e, 'upvote')}
          aria-label="Upvote"
          className="p-0.5 rounded hover:bg-[#EADDCA] disabled:opacity-50 disabled:cursor-not-allowed"
          disabled={isLoading || !userId}
        >
          <ArrowUpIcon 
            className={`h-5 w-5 ${currentUserVoteType === 'upvoted' ? 'text-[#639751]' : ''}`}
            strokeWidth={currentUserVoteType === 'upvoted' ? 2.5 : 1.5} 
          />
        </button>
        <span className="font-medium min-w-[1ch] text-center text-base tabular-nums">
            {localUpvotes - localDownvotes}
        </span>
        <button
          onClick={(e) => handleVote(e, 'downvote')}
          aria-label="Downvote"
          className="p-0.5 rounded hover:bg-[#EADDCA] disabled:opacity-50 disabled:cursor-not-allowed"
          disabled={isLoading || !userId}
        >
          <ArrowDownIcon 
            className={`h-5 w-5 ${currentUserVoteType === 'downvoted' ? 'text-red-500' : ''}`}
            strokeWidth={currentUserVoteType === 'downvoted' ? 2.5 : 1.5} 
          />
        </button>
      </div>
      {errorState && <p className="text-red-500 text-xs mt-1 px-1 text-center">{errorState}</p>}
    </div>
  );
};

VoteButtons.propTypes = {
  upvotes: PropTypes.number.isRequired,
  downvotes: PropTypes.number.isRequired,
  itemId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  itemType: PropTypes.oneOf(['hacks', 'deals', 'events']),
  userId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]), 
  hackId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  dealId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  eventId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
};

export default VoteButtons;
